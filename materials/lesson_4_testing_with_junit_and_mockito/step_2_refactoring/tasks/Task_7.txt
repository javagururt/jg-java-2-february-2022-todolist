К юнит тестам можно относиться и по другому.

Юнит тесты могут быть классной возможностью зафиксировать в коде
требования к программному обеспечению. Тоесть каждый тест не проверяет
happy path, а проверяет выполняется ли определённое конкретное требование
к программному обеспечению. Набор тестов фиксирует и проверяет набор
требований, которые мы предъявляем к нашему программному коду.
Требования должны включать не только проверку happy path, но и то как
должен себя вести наш код в экстремальных (отличных от нормальных)
условиях, должен ли он кидать ошибки, если да то какие, или просто
не падать с NullPointerException если на вход передали некорректные
значения.

К самим тестам можно (и нужно) применять те же требования
clean code как и к продакшен коду. Тесты в идеале должны быть небольшими,
легко читаемыми и понимаемыми другими людьми (в идеале даже не
программистами).

Если тесты для одного класса начинают разрастаться
и постепенно превращаться в большое и длинное полотно, то это явный
признак того, что тестируемый класс перегружен ответственностью, он
слишком за много чего отвечает и поэтому для проверки всех требований
приходится писать большие и длинные тесты. Это явный признак того,
что тестируемый класс нуждается в улучшении (рефакторинге). Если
у класса слишком много ответственности, то можно попробовать разделить
его на более мелкие классы.